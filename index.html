<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>xhr-streamer Demo</title>
  <link href="dist/xhr-streamer.css" rel="stylesheet">
</head>
<body>
  <ul>
    <li><a href="/test/debug.html">Run unit tests in browser.</a></li>
  </ul>
  <video controls id="test-video" autoplay muted>
  </video>
  <script src="dist/xhr-streamer.js"></script>
  <script>
    var video = window.video = document.getElementById('test-video');
    var mse = window.mse = new MediaSource();
    var url = window.URL.createObjectURL(mse);

    video.src = url;

    (function(window, XhrStreamer) {
      var xhrStreamer = window.xhrStreamer = new XhrStreamer();
      var buffers = window.buffers = {};
      var videoAppendQueue = window.videoAppendQueue = [];
      var audioAppendQueue = window.audioAppendQueue = [];
      var append = {};

      ['audio', 'video'].forEach(function(type) {
        append[type + 'Queue'] = [];
        append[type] = function() {
          if (append[type + 'Queue'].length) {
            var nextdata = new Uint8Array(append[type + 'Queue'].shift());

            console.log('appending ' + type + ' ' + nextdata.byteLength);
            buffers[type].appendBuffer(nextdata);
          }
        };
        append[type + 'Shift'] = function() {
          if (!buffers[type].updating && mse.readyState === 'open') {
            append[type]();
          } else {
            console.log(`could not shift ${type}`, {
              updating: buffers[type].updating,
              readyState: mse.readyState
            })
          }
        };
      });


      var createBuffers = function(mimetypes) {
        Object.keys(mimetypes).forEach(function(type) {
          console.log('creating sb ' + mimetypes[type]);
          buffers[type] = mse.addSourceBuffer(mimetypes[type]);
          buffers[type].addEventListener('updateend', append[type + 'Shift']);
          mse.addEventListener('sourceopen', append[type + 'Shift']);
        });

        mse.removeEventListener('sourceopen', createBuffers);
        createBuffers = null;

        Object.keys(mimetypes).forEach(function(type) {
          append[type + 'Shift']();
        });
      };

      xhrStreamer.addEventListener('trackinfo', function(e) {
        createBuffers(e.detail.trackinfo)
      });

      xhrStreamer.addEventListener('data', function(e) {
        const datatype = e.detail.datatype;

        append[datatype + 'Queue'].push(e.detail.data);
        append[datatype + 'Shift']();
      });

      xhrStreamer.addEventListener('done', function(e) {
        var interval = window.setInterval(function() {
          if ((append.videoQueue && append.videoQueue.length !== 0) || (append.audioQueue && append.audioQueue.length !== 0)) {
            return;
          }

          if ((buffers.video && buffers.video.updating) || (buffers.audio && buffers.audio.updating)) {
            return;
          }

          if (mse.readyState !== 'open') {
            return;
          }

          console.log('calling end of stream');
          mse.endOfStream();
          window.clearInterval(interval);
        }, 100)
      });
      xhrStreamer.streamRequest(window.location.origin + '/oceans.webm');


    }(window, window.XhrStreamer));
  </script>
</body>
</html>
